// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { inspirationDestinations } from '@/data/mockData';
import { Destination } from '@/types/travel';

const FALLBACK_SUPABASE_URL = 'https://axdldqmknnjngxqqurlg.supabase.co';
const FALLBACK_SUPABASE_PUBLISHABLE_KEY = 'sb_publishable_qLxYKroavOk5b6mb2PRc3w_kQB9oEGQ';
const SUPABASE_URL = (() => {
  const raw = import.meta.env.VITE_SUPABASE_URL || FALLBACK_SUPABASE_URL;
  if (!raw) return raw;
  if (/^https?:\/\//i.test(raw)) return raw;
  return `https://${raw}`;
})();
const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_PUBLISHABLE_KEY || FALLBACK_SUPABASE_PUBLISHABLE_KEY;
const isValidHttpUrl = (value: string | undefined) => {
  if (!value) return false;
  try {
    const parsed = new URL(value);
    return parsed.protocol === 'http:' || parsed.protocol === 'https:';
  } catch {
    return false;
  }
};
const FORCE_LOCAL_DB =
  import.meta.env.VITE_LOCAL_DB === 'true' ||
  import.meta.env.VITE_DISABLE_SUPABASE === 'true' ||
  SUPABASE_URL === 'local' ||
  SUPABASE_PUBLISHABLE_KEY === 'local' ||
  !SUPABASE_URL ||
  !isValidHttpUrl(SUPABASE_URL) ||
  !SUPABASE_PUBLISHABLE_KEY;
export const isLocalSupabase = FORCE_LOCAL_DB;

const LOCAL_DB_KEY = 'local-db';
const LOCAL_AUTH_USERS_KEY = 'local-auth-users';
const LOCAL_AUTH_SESSION_KEY = 'local-auth-session';
const LOCAL_MFA_KEY = 'local-mfa-state';

type LocalDb = Record<string, Record<string, unknown>[]>;
type LocalUser = {
  id: string;
  email: string;
  password: string;
  user_metadata?: Record<string, unknown>;
};
type LocalSession = {
  user: {
    id: string;
    email: string;
    user_metadata?: Record<string, unknown>;
  };
  access_token: string;
  refresh_token: string;
};
type LocalMfaState = Record<
  string,
  {
    challengeId?: string;
    code?: string;
    expiresAt?: number;
    verifiedUntil?: number;
  }
>;
type LocalRow = Record<string, unknown>;
type LocalQueryResult = { data: unknown; error: Error | null };
type LocalQueryBuilder = {
  select: (columns?: string) => LocalQueryBuilder;
  insert: (data: LocalRow | LocalRow[]) => LocalQueryBuilder;
  upsert: (data: LocalRow | LocalRow[]) => LocalQueryBuilder;
  update: (data: LocalRow) => LocalQueryBuilder;
  delete: () => LocalQueryBuilder;
  eq: (key: string, value: unknown) => LocalQueryBuilder;
  ilike: (key: string, value: unknown) => LocalQueryBuilder;
  order: (key: string, opts?: { ascending?: boolean }) => LocalQueryBuilder;
  single: () => LocalQueryBuilder;
  then: (resolve?: (value: LocalQueryResult) => unknown, reject?: (reason: unknown) => unknown) => Promise<unknown>;
};

const getLocalDb = (): LocalDb => {
  const raw = localStorage.getItem(LOCAL_DB_KEY);
  if (!raw) return {};
  try {
    return JSON.parse(raw) as LocalDb;
  } catch {
    return {};
  }
};

const setLocalDb = (db: LocalDb) => {
  localStorage.setItem(LOCAL_DB_KEY, JSON.stringify(db));
};

const getUsers = (): LocalUser[] => {
  const raw = localStorage.getItem(LOCAL_AUTH_USERS_KEY);
  if (!raw) return [];
  try {
    return JSON.parse(raw) as LocalUser[];
  } catch {
    return [];
  }
};

const setUsers = (users: LocalUser[]) => {
  localStorage.setItem(LOCAL_AUTH_USERS_KEY, JSON.stringify(users));
};

const getSession = (): LocalSession | null => {
  const raw = localStorage.getItem(LOCAL_AUTH_SESSION_KEY);
  if (!raw) return null;
  try {
    return JSON.parse(raw) as LocalSession;
  } catch {
    return null;
  }
};

const setSession = (session: LocalSession | null) => {
  if (!session) {
    localStorage.removeItem(LOCAL_AUTH_SESSION_KEY);
    return;
  }
  localStorage.setItem(LOCAL_AUTH_SESSION_KEY, JSON.stringify(session));
};

const getMfaState = (): LocalMfaState => {
  const raw = localStorage.getItem(LOCAL_MFA_KEY);
  if (!raw) return {};
  try {
    return JSON.parse(raw) as LocalMfaState;
  } catch {
    return {};
  }
};

const setMfaState = (state: LocalMfaState) => {
  localStorage.setItem(LOCAL_MFA_KEY, JSON.stringify(state));
};

const createId = () => {
  if (typeof crypto !== 'undefined' && 'randomUUID' in crypto) {
    return crypto.randomUUID();
  }
  return `${Date.now()}-${Math.random().toString(16).slice(2)}`;
};

const createToken = () => createId();

const authListeners = new Set<(event: string, session: LocalSession | null) => void>();

const emitAuth = (event: string, session: LocalSession | null) => {
  authListeners.forEach((listener) => listener(event, session));
};

const getCurrentUserId = () => {
  return getSession()?.user?.id || null;
};

const isMfaVerified = (userId: string | null) => {
  if (!userId) return false;
  const state = getMfaState();
  const entry = state[userId];
  if (!entry?.verifiedUntil) return false;
  return entry.verifiedUntil > Date.now();
};

const ensureTable = (db: LocalDb, table: string) => {
  if (!db[table]) db[table] = [];
  return db[table] as Record<string, unknown>[];
};

const allowedTables = new Set(['saved_trips', 'profiles', 'guide_posts', 'blog_posts', 'destinations']);

type RestCountry = {
  name?: { common?: string };
  cca2?: string;
  cca3?: string;
  region?: string;
  subregion?: string;
  capital?: string[];
  latlng?: number[];
  capitalInfo?: { latlng?: number[] };
  flags?: { png?: string; svg?: string };
  currencies?: Record<string, { name?: string; symbol?: string }>;
  landlocked?: boolean;
};

const toSlug = (value: string) => {
  return value
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');
};

const toKey = (value: string) => toSlug(value || '');

const islandNameSet = new Set([
  'bahamas',
  'barbados',
  'cabo-verde',
  'cape-verde',
  'comoros',
  'cuba',
  'dominican-republic',
  'east-timor',
  'fiji',
  'grenada',
  'haiti',
  'iceland',
  'indonesia',
  'ireland',
  'jamaica',
  'japan',
  'kiribati',
  'maldives',
  'marshall-islands',
  'mauritius',
  'micronesia',
  'new-zealand',
  'palau',
  'papua-new-guinea',
  'philippines',
  'saint-kitts-and-nevis',
  'saint-lucia',
  'saint-vincent-and-the-grenadines',
  'samoa',
  'seychelles',
  'singapore',
  'solomon-islands',
  'sri-lanka',
  'taiwan',
  'tonga',
  'trinidad-and-tobago',
  'tuvalu',
  'united-kingdom',
  'vanuatu',
]);

const defaultDestinationImage = 'https://images.unsplash.com/photo-1476514525535-07fb3b4ae5f1?q=80&w=2070&auto=format&fit=crop';

const imageFromName = (name?: string, fallback = defaultDestinationImage) => {
  if (!name) return fallback;
  return `https://source.unsplash.com/featured/?${encodeURIComponent(name)}`;
};

const regionCostMap: Record<string, { cost: number; currencyFallback: string }> = {
  Europe: { cost: 110, currencyFallback: 'EUR' },
  Asia: { cost: 60, currencyFallback: 'USD' },
  Africa: { cost: 70, currencyFallback: 'USD' },
  Americas: { cost: 120, currencyFallback: 'USD' },
  Oceania: { cost: 140, currencyFallback: 'AUD' },
  Antarctic: { cost: 120, currencyFallback: 'USD' },
  Other: { cost: 90, currencyFallback: 'USD' },
};

const getRegionDefaults = (regionName?: string | null) => {
  if (regionName && regionCostMap[regionName]) return regionCostMap[regionName];
  return regionCostMap.Other;
};

const buildCountriesFromIntl = (): RestCountry[] => {
  const supportedValuesOf = (Intl as unknown as { supportedValuesOf?: (type: string) => string[] }).supportedValuesOf;
  if (typeof supportedValuesOf !== 'function') return [];
  const display = new Intl.DisplayNames(['en'], { type: 'region' });
  return supportedValuesOf('region')
    .map((code) => ({
      name: { common: display.of(code) || code },
      cca2: code,
      cca3: code,
      region: 'Other',
    }))
    .filter((entry) => entry.name?.common);
};

const extraDestinations: Destination[] = [
  {
    id: 'island-zakynthos',
    name: 'Zakynthos',
    country: 'Griechenland',
    countryCode: 'GR',
    type: 'island',
    types: ['island'],
    imageUrl: 'https://images.unsplash.com/photo-1629286521433-dfa4637fbe9a?q=80&w=800',
    description: 'Ionische Insel mit türkisfarbenen Buchten, Steilklippen und berühmtem Schiffswrackstrand.',
    highlights: ['Navagio Beach', 'Blaue Grotten', 'Gerakas Beach', 'Keri Cliffs'],
    bestSeason: 'Mai bis Oktober',
    averageDailyCost: 110,
    currency: 'EUR',
    visaInfo: 'Kein Visum erforderlich (EU/Schengen).',
    vaccinationInfo: 'Standardimpfungen empfohlen.',
    healthSafetyInfo: 'Starker Sonnenschutz und ausreichend Trinkwasser; in der Hochsaison früh zu beliebten Stränden.',
    source: 'curated',
    parentId: 'country-grc',
    coords: { lat: 37.787, lon: 20.899 },
  },
  {
    id: 'island-santorini',
    name: 'Santorin',
    country: 'Griechenland',
    countryCode: 'GR',
    type: 'island',
    types: ['island'],
    imageUrl: 'https://images.unsplash.com/photo-1500375592092-40eb2168fd21?w=800&q=80',
    description: 'Vulkaninsel mit weiß‑blauen Dörfern, spektakulärer Caldera und Sonnenuntergängen.',
    highlights: ['Caldera', 'Oia', 'Fira', 'Schwarze Sandstrände'],
    bestSeason: 'Mai bis Oktober',
    averageDailyCost: 140,
    currency: 'EUR',
    visaInfo: 'Kein Visum erforderlich (EU/Schengen).',
    vaccinationInfo: 'Standardimpfungen empfohlen.',
    healthSafetyInfo: 'Viel Sonne und steile Wege – feste Schuhe und Sonnenschutz einplanen.',
    source: 'curated',
    parentId: 'country-grc',
    coords: { lat: 36.393, lon: 25.461 },
  },
  {
    id: 'island-mykonos',
    name: 'Mykonos',
    country: 'Griechenland',
    countryCode: 'GR',
    type: 'island',
    types: ['island'],
    imageUrl: 'https://images.unsplash.com/photo-1500534314209-a25ddb2bd429?w=800&q=80',
    description: 'Kykladeninsel mit lebendiger Altstadt, Windmühlen und lebhaften Strandbars.',
    highlights: ['Windmühlen', 'Little Venice', 'Paradise Beach', 'Altstadt'],
    bestSeason: 'Mai bis September',
    averageDailyCost: 160,
    currency: 'EUR',
    visaInfo: 'Kein Visum erforderlich (EU/Schengen).',
    vaccinationInfo: 'Standardimpfungen empfohlen.',
    healthSafetyInfo: 'Hochsaison ist sehr voll und teuer – rechtzeitig buchen.',
    source: 'curated',
    parentId: 'country-grc',
    coords: { lat: 37.446, lon: 25.328 },
  },
  {
    id: 'island-crete',
    name: 'Kreta',
    country: 'Griechenland',
    countryCode: 'GR',
    type: 'island',
    types: ['island'],
    imageUrl: 'https://images.unsplash.com/photo-1507525428034-b723cf961d3e?w=800&q=80',
    description: 'Größte griechische Insel mit Stränden, Schluchten, Bergen und minoischer Geschichte.',
    highlights: ['Samaria-Schlucht', 'Palast von Knossos', 'Elafonissi', 'Chania'],
    bestSeason: 'April bis Oktober',
    averageDailyCost: 120,
    currency: 'EUR',
    visaInfo: 'Kein Visum erforderlich (EU/Schengen).',
    vaccinationInfo: 'Standardimpfungen empfohlen.',
    healthSafetyInfo: 'Mietwagen ideal für Erkundung; in den Bergen wechselhaftes Wetter beachten.',
    source: 'curated',
    parentId: 'country-grc',
    coords: { lat: 35.24, lon: 24.809 },
  },
  {
    id: 'island-rhodes',
    name: 'Rhodos',
    country: 'Griechenland',
    countryCode: 'GR',
    type: 'island',
    types: ['island'],
    imageUrl: 'https://images.unsplash.com/photo-1501785888041-af3ef285b470?w=800&q=80',
    description: 'Sonnenreiche Insel mit mittelalterlicher Altstadt, Stränden und historischen Burgen.',
    highlights: ['Altstadt von Rhodos', 'Lindos', 'Strände', 'Buchten'],
    bestSeason: 'Mai bis Oktober',
    averageDailyCost: 115,
    currency: 'EUR',
    visaInfo: 'Kein Visum erforderlich (EU/Schengen).',
    vaccinationInfo: 'Standardimpfungen empfohlen.',
    healthSafetyInfo: 'Sonnenschutz und ausreichend Wasser; Altstadt ist kopfsteingepflastert.',
    source: 'curated',
    parentId: 'country-grc',
    coords: { lat: 36.434, lon: 28.217 },
  },
  {
    id: 'island-corfu',
    name: 'Korfu',
    country: 'Griechenland',
    countryCode: 'GR',
    type: 'island',
    types: ['island'],
    imageUrl: 'https://images.unsplash.com/photo-1506929562872-bb421503ef21?w=800&q=80',
    description: 'Grüne Insel im Ionischen Meer mit venezianischer Altstadt und ruhigen Buchten.',
    highlights: ['Altstadt', 'Paleokastritsa', 'Olivenhaine', 'Buchten'],
    bestSeason: 'Mai bis Oktober',
    averageDailyCost: 110,
    currency: 'EUR',
    visaInfo: 'Kein Visum erforderlich (EU/Schengen).',
    vaccinationInfo: 'Standardimpfungen empfohlen.',
    healthSafetyInfo: 'Leichte Mückenbelastung im Sommer – Repellent mitnehmen.',
    source: 'curated',
    parentId: 'country-grc',
    coords: { lat: 39.624, lon: 19.922 },
  },
  {
    id: 'island-mallorca',
    name: 'Mallorca',
    country: 'Spanien',
    countryCode: 'ES',
    type: 'island',
    types: ['island'],
    imageUrl: 'https://images.unsplash.com/photo-1500530855697-b586d89ba3ee?w=800&q=80',
    description: 'Baleareninsel mit abwechslungsreicher Küste, Bergen und lebendiger Hauptstadt.',
    highlights: ['Serra de Tramuntana', 'Palma', 'Cala Mondragó', 'Valldemossa'],
    bestSeason: 'April bis Oktober',
    averageDailyCost: 130,
    currency: 'EUR',
    visaInfo: 'Kein Visum erforderlich (EU/Schengen).',
    vaccinationInfo: 'Standardimpfungen empfohlen.',
    healthSafetyInfo: 'In der Hochsaison früh reservieren; Mietwagen für abgelegene Buchten hilfreich.',
    source: 'curated',
    parentId: 'country-esp',
    coords: { lat: 39.613, lon: 2.882 },
  },
  {
    id: 'island-ibiza',
    name: 'Ibiza',
    country: 'Spanien',
    countryCode: 'ES',
    type: 'island',
    types: ['island'],
    imageUrl: 'https://images.unsplash.com/photo-1469474968028-56623f02e42e?w=800&q=80',
    description: 'Baleareninsel mit ruhigen Buchten, Altstadt und legendären Sonnenuntergängen.',
    highlights: ['Cala Comte', 'Dalt Vila', 'Sonnenuntergänge', 'Strände'],
    bestSeason: 'Mai bis Oktober',
    averageDailyCost: 150,
    currency: 'EUR',
    visaInfo: 'Kein Visum erforderlich (EU/Schengen).',
    vaccinationInfo: 'Standardimpfungen empfohlen.',
    healthSafetyInfo: 'Nachts Transfers planen; tagsüber Sonnenschutz wichtig.',
    source: 'curated',
    parentId: 'country-esp',
    coords: { lat: 38.906, lon: 1.42 },
  },
  {
    id: 'island-sicily',
    name: 'Sizilien',
    country: 'Italien',
    countryCode: 'IT',
    type: 'island',
    types: ['island'],
    imageUrl: 'https://images.unsplash.com/photo-1489515217757-5fd1be406fef?w=800&q=80',
    description: 'Italiens größte Insel mit Vulkanlandschaften, Stränden und barocken Städten.',
    highlights: ['Ätna', 'Taormina', 'Cefalù', 'Val di Noto'],
    bestSeason: 'April bis Oktober',
    averageDailyCost: 125,
    currency: 'EUR',
    visaInfo: 'Kein Visum erforderlich (EU/Schengen).',
    vaccinationInfo: 'Standardimpfungen empfohlen.',
    healthSafetyInfo: 'Sommer sehr heiß – Ausflüge früh oder spät planen.',
    source: 'curated',
    parentId: 'country-ita',
    coords: { lat: 37.599, lon: 14.015 },
  },
  {
    id: 'island-sardinia',
    name: 'Sardinien',
    country: 'Italien',
    countryCode: 'IT',
    type: 'island',
    types: ['island'],
    imageUrl: 'https://images.unsplash.com/photo-1470770841072-f978cf4d019e?w=800&q=80',
    description: 'Mittelmeerinsel mit türkisfarbenen Buchten, Granitküste und traditionellen Dörfern.',
    highlights: ['Costa Smeralda', 'La Maddalena', 'Cala Luna', 'Alghero'],
    bestSeason: 'Mai bis Oktober',
    averageDailyCost: 130,
    currency: 'EUR',
    visaInfo: 'Kein Visum erforderlich (EU/Schengen).',
    vaccinationInfo: 'Standardimpfungen empfohlen.',
    healthSafetyInfo: 'Mietwagen sinnvoll; viele Buchten sind nur per Auto erreichbar.',
    source: 'curated',
    parentId: 'country-ita',
    coords: { lat: 40.12, lon: 9.012 },
  },
  {
    id: 'island-madeira',
    name: 'Madeira',
    country: 'Portugal',
    countryCode: 'PT',
    type: 'island',
    types: ['island'],
    imageUrl: 'https://images.unsplash.com/photo-1491553895911-0055eca6402d?w=800&q=80',
    description: 'Ganzjähriges Wanderparadies mit Levadas, Steilküsten und üppiger Vegetation.',
    highlights: ['Levadas', 'Funchal', 'Pico do Arieiro', 'Klifflandschaften'],
    bestSeason: 'Ganzjährig',
    averageDailyCost: 110,
    currency: 'EUR',
    visaInfo: 'Kein Visum erforderlich (EU/Schengen).',
    vaccinationInfo: 'Standardimpfungen empfohlen.',
    healthSafetyInfo: 'Wetter kann schnell wechseln – Regenjacke und gutes Schuhwerk mitnehmen.',
    source: 'curated',
    parentId: 'country-prt',
    coords: { lat: 32.76, lon: -16.959 },
  },
  {
    id: 'island-azores',
    name: 'Azoren',
    country: 'Portugal',
    countryCode: 'PT',
    type: 'island',
    types: ['island'],
    imageUrl: 'https://images.unsplash.com/photo-1482192505345-5655af888cc4?w=800&q=80',
    description: 'Atlantischer Archipel mit Kraterseen, Thermalquellen und besten Whale-Watching-Spots.',
    highlights: ['Sete Cidades', 'Whale Watching', 'Wandern', 'Thermalquellen'],
    bestSeason: 'Mai bis Oktober',
    averageDailyCost: 105,
    currency: 'EUR',
    visaInfo: 'Kein Visum erforderlich (EU/Schengen).',
    vaccinationInfo: 'Standardimpfungen empfohlen.',
    healthSafetyInfo: 'Wechselhaftes Wetter; Kleidung im Zwiebellook einplanen.',
    source: 'curated',
    parentId: 'country-prt',
    coords: { lat: 37.742, lon: -25.675 },
  },
];

const curatedDestinations = [...inspirationDestinations, ...extraDestinations];

const isIslandCountry = (country: RestCountry, name: string) => {
  const key = toKey(name);
  if (key.includes('island') || key.includes('islands')) return true;
  if (country.region && country.region.toLowerCase() === 'oceania') return true;
  if (islandNameSet.has(key)) return true;
  return false;
};

const seedDestinations = async (db: LocalDb) => {
  const rows = ensureTable(db, 'destinations');
  if (rows.length > 200) return;
  const now = new Date().toISOString();
  const entries: LocalRow[] = [];
  const entryById = new Map<string, LocalRow>();
  const regionByName = new Map<string, LocalRow>();
  const subregionByName = new Map<string, LocalRow>();
  const countryByName = new Map<string, LocalRow>();
  const countryByCode = new Map<string, LocalRow>();

  const addEntry = (entry: LocalRow) => {
    entries.push(entry);
    entryById.set(entry.id as string, entry);
    return entry;
  };

  const ensureRegion = (name: string) => {
    const key = toKey(name);
    const existing = regionByName.get(key);
    if (existing) return existing;
    const regionDefaults = getRegionDefaults(name);
    const entry = addEntry({
      id: `region-${key}`,
      name,
      country: name,
      country_code: null,
      type: 'region',
      types: ['region'],
      image_url: imageFromName(name),
      description: null,
      highlights: [],
      best_season: null,
      average_daily_cost: regionDefaults.cost,
      currency: regionDefaults.currencyFallback,
      visa_info: null,
      vaccination_info: null,
      health_safety_info: null,
      source: 'restcountries',
      parent_id: null,
      coords_lat: null,
      coords_lon: null,
      children_count: null,
      created_at: now,
    });
    regionByName.set(key, entry);
    return entry;
  };

  const ensureSubregion = (region: LocalRow, name: string) => {
    const key = `${toKey(region.name as string)}-${toKey(name)}`;
    const existing = subregionByName.get(key);
    if (existing) return existing;
    const regionDefaults = getRegionDefaults(region.name as string);
    const entry = addEntry({
      id: `region-${key}`,
      name,
      country: region.name,
      country_code: null,
      type: 'region',
      types: ['region'],
      image_url: imageFromName(name),
      description: null,
      highlights: [],
      best_season: null,
      average_daily_cost: regionDefaults.cost,
      currency: regionDefaults.currencyFallback,
      visa_info: null,
      vaccination_info: null,
      health_safety_info: null,
      source: 'restcountries',
      parent_id: region.id,
      coords_lat: null,
      coords_lon: null,
      children_count: null,
      created_at: now,
    });
    subregionByName.set(key, entry);
    return entry;
  };

  const ensureUniqueId = (base: string) => {
    let id = base;
    let idx = 1;
    while (entryById.has(id)) {
      id = `${base}-${idx}`;
      idx += 1;
    }
    return id;
  };

  let list: RestCountry[] = [];
  try {
    const resp = await fetch('https://restcountries.com/v3.1/all?fields=name,cca2,cca3,region,subregion,capital,latlng,capitalInfo,currencies,flags,landlocked');
    if (!resp.ok) throw new Error('restcountries');
    list = (await resp.json()) as RestCountry[];
  } catch {
    list = buildCountriesFromIntl();
  }

  list.forEach((country) => {
    const name = country.name?.common;
    const cca3 = country.cca3;
    if (!name || !cca3) return;
    const regionName = country.region || 'Other';
    const regionDefaults = getRegionDefaults(regionName);
    const region = ensureRegion(regionName);
    const subregion = country.subregion ? ensureSubregion(region, country.subregion) : null;
    const types = ['country'];
    if (isIslandCountry(country, name)) types.push('island');
    const currencyCode = country.currencies ? Object.keys(country.currencies)[0] : null;
    const countryEntry = addEntry({
      id: `country-${cca3.toLowerCase()}`,
      name,
      country: name,
      country_code: country.cca2 || null,
      type: 'country',
      types,
      image_url: imageFromName(name),
      description: null,
      highlights: [],
      best_season: null,
      average_daily_cost: regionDefaults.cost,
      currency: currencyCode || regionDefaults.currencyFallback,
      visa_info: null,
      vaccination_info: null,
      health_safety_info: null,
      source: 'restcountries',
      parent_id: (subregion?.id as string) || (region.id as string),
      coords_lat: country.latlng?.[0] ?? null,
      coords_lon: country.latlng?.[1] ?? null,
      children_count: null,
      created_at: now,
    });
    countryByName.set(toKey(name), countryEntry);
    if (country.cca2) countryByCode.set(country.cca2.toUpperCase(), countryEntry);
    (country.capital || []).forEach((capital) => {
      if (!capital) return;
      const capitalId = ensureUniqueId(`city-${cca3.toLowerCase()}-${toSlug(capital)}`);
      addEntry({
        id: capitalId,
        name: capital,
        country: name,
        country_code: country.cca2 || null,
        type: 'city',
        types: ['city'],
        image_url: imageFromName(capital),
        description: null,
        highlights: [],
        best_season: null,
        average_daily_cost: regionDefaults.cost,
        currency: currencyCode || regionDefaults.currencyFallback,
        visa_info: null,
        vaccination_info: null,
        health_safety_info: null,
        source: 'restcountries',
        parent_id: countryEntry.id,
        coords_lat: country.capitalInfo?.latlng?.[0] ?? null,
        coords_lon: country.capitalInfo?.latlng?.[1] ?? null,
        children_count: null,
        created_at: now,
      });
    });
  });

  if (list.length === 0) {
    curatedDestinations.forEach((d) => {
      addEntry({
        id: d.id,
        name: d.name,
        country: d.country,
        country_code: d.countryCode || null,
        type: d.type,
        types: d.types && d.types.length > 0 ? d.types : [d.type],
        image_url: d.imageUrl,
        description: d.description,
        highlights: d.highlights,
        best_season: d.bestSeason || null,
        average_daily_cost: d.averageDailyCost ?? null,
        currency: d.currency || null,
        visa_info: d.visaInfo || null,
        vaccination_info: d.vaccinationInfo || null,
        health_safety_info: d.healthSafetyInfo || null,
        source: d.source || null,
        parent_id: d.parentId || null,
        coords_lat: d.coords?.lat ?? null,
        coords_lon: d.coords?.lon ?? null,
        children_count: d.childrenCount ?? null,
        created_at: now,
      });
    });
  }

  curatedDestinations.forEach((d) => {
    const nameKey = toKey(d.name);
    const isCountryLevel = toKey(d.name) === toKey(d.country);
    const byName = countryByName.get(nameKey);
    const byCode = isCountryLevel && d.countryCode ? countryByCode.get(d.countryCode.toUpperCase()) : null;
    const target = byName || byCode;
    if (target) {
      const existingTypes = Array.isArray(target.types) ? target.types.slice() : [];
      const nextTypes = new Set(existingTypes);
      nextTypes.add(d.type);
      (d.types || []).forEach((t) => nextTypes.add(t));
      target.types = Array.from(nextTypes);
      target.image_url = d.imageUrl || target.image_url;
      target.description = d.description || target.description;
      target.highlights = d.highlights || target.highlights;
      target.best_season = d.bestSeason || target.best_season;
      target.average_daily_cost = d.averageDailyCost ?? target.average_daily_cost;
      target.currency = d.currency || target.currency;
      target.visa_info = d.visaInfo || target.visa_info;
      target.vaccination_info = d.vaccinationInfo || target.vaccination_info;
      target.health_safety_info = d.healthSafetyInfo || target.health_safety_info;
      target.source = d.source || target.source;
      return;
    }
    const parentFromCode = d.countryCode ? countryByCode.get(d.countryCode.toUpperCase()) : null;
    const id = ensureUniqueId(`dest-${toSlug(d.name)}`);
    addEntry({
      id,
      name: d.name,
      country: d.country,
      country_code: d.countryCode || null,
      type: d.type,
      types: d.types && d.types.length > 0 ? d.types : [d.type],
      image_url: d.imageUrl,
      description: d.description,
      highlights: d.highlights,
      best_season: d.bestSeason || null,
      average_daily_cost: d.averageDailyCost ?? null,
      currency: d.currency || null,
      visa_info: d.visaInfo || null,
      vaccination_info: d.vaccinationInfo || null,
      health_safety_info: d.healthSafetyInfo || null,
      source: d.source || null,
      parent_id: (parentFromCode?.id as string) || d.parentId || null,
      coords_lat: d.coords?.lat ?? null,
      coords_lon: d.coords?.lon ?? null,
      children_count: d.childrenCount ?? null,
      created_at: now,
    });
  });

  const childCounts = new Map<string, number>();
  entries.forEach((entry) => {
    if (!entry.parent_id) return;
    const count = childCounts.get(entry.parent_id as string) || 0;
    childCounts.set(entry.parent_id as string, count + 1);
  });
  entries.forEach((entry) => {
    const count = childCounts.get(entry.id as string);
    if (typeof count === 'number') entry.children_count = count;
  });

  rows.splice(0, rows.length, ...entries);
  setLocalDb(db);
};

const localSupabase = {
  auth: {
    onAuthStateChange: (callback: (event: string, session: LocalSession | null) => void) => {
      authListeners.add(callback);
      setTimeout(() => {
        callback('INITIAL_SESSION', getSession());
      }, 0);
      return {
        data: {
          subscription: {
            unsubscribe: () => authListeners.delete(callback),
          },
        },
      };
    },
    getSession: async () => ({ data: { session: getSession() }, error: null }),
    signUp: async ({ email, password, options }: { email: string; password: string; options?: { data?: Record<string, unknown> } }) => {
      const users = getUsers();
      if (users.some((u) => u.email.toLowerCase() === email.toLowerCase())) {
        return { data: null, error: new Error('User already registered') };
      }
      const user = {
        id: createId(),
        email,
        user_metadata: options?.data || {},
      };
      const stored: LocalUser = {
        id: user.id,
        email,
        password,
        user_metadata: user.user_metadata,
      };
      users.push(stored);
      setUsers(users);
      if (stored.user_metadata?.display_name) {
        const db = getLocalDb();
        const profiles = ensureTable(db, 'profiles');
        profiles.push({ user_id: stored.id, display_name: stored.user_metadata.display_name });
        setLocalDb(db);
      }
      const session: LocalSession = {
        user,
        access_token: createToken(),
        refresh_token: createToken(),
      };
      setSession(session);
      emitAuth('SIGNED_IN', session);
      return { data: { user, session }, error: null };
    },
    signInWithPassword: async ({ email, password }: { email: string; password: string }) => {
      const users = getUsers();
      const found = users.find((u) => u.email.toLowerCase() === email.toLowerCase());
      if (!found || found.password !== password) {
        return { data: null, error: new Error('Invalid login credentials') };
      }
      const user = {
        id: found.id,
        email: found.email,
        user_metadata: found.user_metadata || {},
      };
      const session: LocalSession = {
        user,
        access_token: createToken(),
        refresh_token: createToken(),
      };
      setSession(session);
      emitAuth('SIGNED_IN', session);
      return { data: { user, session }, error: null };
    },
    signOut: async () => {
      setSession(null);
      emitAuth('SIGNED_OUT', null);
      return { error: null };
    },
    setSession: async (_tokens: { access_token: string; refresh_token: string }) => {
      return { data: { session: getSession() }, error: null };
    },
    exchangeCodeForSession: async (_code: string) => {
      return { data: { session: getSession() }, error: null };
    },
    updateUser: async ({ password, data }: { password?: string; data?: Record<string, unknown> }) => {
      const session = getSession();
      if (!session?.user?.id) {
        return { data: null, error: new Error('No active session') };
      }
      const users = getUsers();
      const idx = users.findIndex((u) => u.id === session.user.id);
      if (idx === -1) {
        return { data: null, error: new Error('User not found') };
      }
      const updated: LocalUser = {
        ...users[idx],
        password: password || users[idx].password,
        user_metadata: { ...(users[idx].user_metadata || {}), ...(data || {}) },
      };
      users[idx] = updated;
      setUsers(users);
      const nextSession: LocalSession = {
        ...session,
        user: {
          id: updated.id,
          email: updated.email,
          user_metadata: updated.user_metadata || {},
        },
      };
      setSession(nextSession);
      emitAuth('USER_UPDATED', nextSession);
      return { data: { user: nextSession.user }, error: null };
    },
    resetPasswordForEmail: async (_email: string) => ({ data: {}, error: null }),
    resend: async (_payload: { type: string; email: string }) => ({ data: {}, error: null }),
    mfa: {
      listFactors: async () => {
        const userId = getCurrentUserId();
        const verified = isMfaVerified(userId);
        return { data: { totp: [{ id: 'local', status: verified ? 'verified' : 'unverified' }] }, error: null };
      },
      challenge: async (_payload: { factorId: string }) => {
        const userId = getCurrentUserId();
        if (!userId) {
          return { data: null, error: new Error('No active session') };
        }
        const code = Math.floor(100000 + Math.random() * 900000).toString();
        const challengeId = createId();
        const expiresAt = Date.now() + 5 * 60 * 1000;
        const state = getMfaState();
        state[userId] = { ...state[userId], challengeId, code, expiresAt };
        setMfaState(state);
        return { data: { id: challengeId, expires_at: new Date(expiresAt).toISOString(), code }, error: null };
      },
      verify: async (payload: { factorId: string; challengeId: string; code: string }) => {
        const userId = getCurrentUserId();
        if (!userId) {
          return { data: null, error: new Error('No active session') };
        }
        const state = getMfaState();
        const entry = state[userId];
        if (!entry?.challengeId || entry.challengeId !== payload.challengeId) {
          return { data: null, error: new Error('Challenge invalid') };
        }
        if (!entry.expiresAt || entry.expiresAt < Date.now()) {
          return { data: null, error: new Error('Challenge expired') };
        }
        if (entry.code !== payload.code) {
          return { data: null, error: new Error('Code invalid') };
        }
        state[userId] = { ...entry, verifiedUntil: Date.now() + 8 * 60 * 60 * 1000 };
        setMfaState(state);
        return { data: { currentLevel: 'aal2' }, error: null };
      },
      getAuthenticatorAssuranceLevel: async () => {
        const userId = getCurrentUserId();
        const verified = isMfaVerified(userId);
        return { data: { currentLevel: verified ? 'aal2' : 'aal1' }, error: null };
      },
    },
  },
  from: (table: string): LocalQueryBuilder => {
    let action: 'select' | 'insert' | 'update' | 'delete' | 'upsert' = 'select';
    let payload: LocalRow | LocalRow[] | null = null;
    let selectColumns: string | null = null;
    const filters: { key: string; value: unknown; type: 'eq' | 'ilike' }[] = [];
    let orderBy: { key: string; ascending: boolean } | null = null;
    let single = false;

    const applyFilters = (rows: Record<string, unknown>[]) => {
      return rows.filter((row) => {
        return filters.every((f) => {
          const value = row[f.key];
          if (f.type === 'ilike') {
            const search = String(f.value || '').toLowerCase().replace(/%/g, '');
            return String(value || '').toLowerCase().includes(search);
          }
          return value === f.value;
        });
      });
    };

    const execute = async (): Promise<LocalQueryResult> => {
      if (!allowedTables.has(table)) {
        return { data: null, error: new Error('Local table not available') };
      }
      const db = getLocalDb();
      const shouldSeedDestinations = localStorage.getItem('seedDestinations') === 'true';
      if (table === 'destinations' && shouldSeedDestinations) await seedDestinations(db);
      const rows = ensureTable(db, table);
      let result: LocalRow[] = rows.slice();
      if (filters.length) result = applyFilters(result);

      if (action === 'select') {
        if (orderBy) {
          result.sort((a, b) => {
            const av = a[orderBy.key];
            const bv = b[orderBy.key];
            if (av === bv) return 0;
            if (av === undefined || av === null) return orderBy.ascending ? 1 : -1;
            if (bv === undefined || bv === null) return orderBy.ascending ? -1 : 1;
            return (av > bv ? 1 : -1) * (orderBy.ascending ? 1 : -1);
          });
        }
        if (selectColumns && selectColumns !== '*') {
          const cols = selectColumns.split(',').map((c) => c.trim());
          result = result.map((row) => {
            const picked: Record<string, unknown> = {};
            cols.forEach((c) => {
              picked[c] = row[c];
            });
            return picked;
          });
        }
        if (single) {
          return { data: result[0] ?? null, error: null };
        }
        return { data: result, error: null };
      }

      if (action === 'insert') {
        const toInsert = Array.isArray(payload) ? payload : [payload];
        const inserted = toInsert.map((row) => ({
          ...row,
          id: (row as LocalRow)?.id || createId(),
          created_at: (row as LocalRow)?.created_at || new Date().toISOString(),
        }));
        rows.unshift(...inserted);
        setLocalDb(db);
        return { data: inserted, error: null };
      }

      if (action === 'upsert') {
        const toUpsert = Array.isArray(payload) ? payload : [payload];
        const updated: LocalRow[] = [];
        toUpsert.forEach((row) => {
          const id = (row as LocalRow)?.id || createId();
          const idx = rows.findIndex((r) => r.id === id);
          const next: LocalRow = { ...(rows[idx] || {}), ...(row as LocalRow), id };
          if (idx === -1) {
            rows.unshift({ ...next, created_at: next.created_at || new Date().toISOString() });
          } else {
            rows[idx] = next;
          }
          updated.push(next);
        });
        setLocalDb(db);
        return { data: updated, error: null };
      }

      if (action === 'update') {
        const updated: Record<string, unknown>[] = [];
        rows.forEach((row, idx) => {
          if (applyFilters([row]).length) {
            const next = { ...row, ...(payload as LocalRow) };
            rows[idx] = next;
            updated.push(next);
          }
        });
        setLocalDb(db);
        return { data: updated, error: null };
      }

      if (action === 'delete') {
        const remaining = rows.filter((row) => !applyFilters([row]).length);
        const deleted = rows.filter((row) => applyFilters([row]).length);
        db[table] = remaining;
        setLocalDb(db);
        return { data: deleted, error: null };
      }

      return { data: null, error: null };
    };

    const builder: LocalQueryBuilder = {
      select: (columns?: string) => {
        action = 'select';
        selectColumns = columns || '*';
        return builder;
      },
      insert: (data: LocalRow | LocalRow[]) => {
        action = 'insert';
        payload = data;
        return builder;
      },
      upsert: (data: LocalRow | LocalRow[]) => {
        action = 'upsert';
        payload = data;
        return builder;
      },
      update: (data: LocalRow) => {
        action = 'update';
        payload = data;
        return builder;
      },
      delete: () => {
        action = 'delete';
        return builder;
      },
      eq: (key: string, value: unknown) => {
        filters.push({ key, value, type: 'eq' });
        return builder;
      },
      ilike: (key: string, value: unknown) => {
        filters.push({ key, value, type: 'ilike' });
        return builder;
      },
      order: (key: string, opts?: { ascending?: boolean }) => {
        orderBy = { key, ascending: opts?.ascending !== false };
        return builder;
      },
      single: () => {
        single = true;
        return builder;
      },
      then: (resolve, reject) => execute().then(resolve, reject),
    };

    return builder;
  },
};

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = (isLocalSupabase
  ? (localSupabase as unknown as ReturnType<typeof createClient<Database>>)
  : createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
      auth: {
        storage: localStorage,
        persistSession: true,
        autoRefreshToken: true,
      },
    })) as ReturnType<typeof createClient<Database>>;
