// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { inspirationDestinations } from '@/data/mockData';

const SUPABASE_URL = (() => {
  const raw = import.meta.env.VITE_SUPABASE_URL;
  if (!raw) return raw;
  if (/^https?:\/\//i.test(raw)) return raw;
  return `https://${raw}`;
})();
const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_PUBLISHABLE_KEY;
const isValidHttpUrl = (value: string | undefined) => {
  if (!value) return false;
  try {
    const parsed = new URL(value);
    return parsed.protocol === 'http:' || parsed.protocol === 'https:';
  } catch {
    return false;
  }
};
const FORCE_LOCAL_DB =
  import.meta.env.VITE_LOCAL_DB === 'true' ||
  import.meta.env.VITE_DISABLE_SUPABASE === 'true' ||
  SUPABASE_URL === 'local' ||
  SUPABASE_PUBLISHABLE_KEY === 'local' ||
  !SUPABASE_URL ||
  !isValidHttpUrl(SUPABASE_URL) ||
  !SUPABASE_PUBLISHABLE_KEY;
const IS_LOVABLE_HOST = typeof window !== 'undefined' && window.location.hostname.endsWith('lovableproject.com');
export const isLocalSupabase = FORCE_LOCAL_DB || IS_LOVABLE_HOST;

const LOCAL_DB_KEY = 'local-db';
const LOCAL_AUTH_USERS_KEY = 'local-auth-users';
const LOCAL_AUTH_SESSION_KEY = 'local-auth-session';
const LOCAL_MFA_KEY = 'local-mfa-state';

type LocalDb = Record<string, Record<string, unknown>[]>;
type LocalUser = {
  id: string;
  email: string;
  password: string;
  user_metadata?: Record<string, unknown>;
};
type LocalSession = {
  user: {
    id: string;
    email: string;
    user_metadata?: Record<string, unknown>;
  };
  access_token: string;
  refresh_token: string;
};
type LocalMfaState = Record<
  string,
  {
    challengeId?: string;
    code?: string;
    expiresAt?: number;
    verifiedUntil?: number;
  }
>;
type LocalRow = Record<string, unknown>;
type LocalQueryResult = { data: unknown; error: Error | null };
type LocalQueryBuilder = {
  select: (columns?: string) => LocalQueryBuilder;
  insert: (data: LocalRow | LocalRow[]) => LocalQueryBuilder;
  upsert: (data: LocalRow | LocalRow[]) => LocalQueryBuilder;
  update: (data: LocalRow) => LocalQueryBuilder;
  delete: () => LocalQueryBuilder;
  eq: (key: string, value: unknown) => LocalQueryBuilder;
  ilike: (key: string, value: unknown) => LocalQueryBuilder;
  order: (key: string, opts?: { ascending?: boolean }) => LocalQueryBuilder;
  single: () => LocalQueryBuilder;
  then: (resolve?: (value: LocalQueryResult) => unknown, reject?: (reason: unknown) => unknown) => Promise<unknown>;
};

const getLocalDb = (): LocalDb => {
  const raw = localStorage.getItem(LOCAL_DB_KEY);
  if (!raw) return {};
  try {
    return JSON.parse(raw) as LocalDb;
  } catch {
    return {};
  }
};

const setLocalDb = (db: LocalDb) => {
  localStorage.setItem(LOCAL_DB_KEY, JSON.stringify(db));
};

const getUsers = (): LocalUser[] => {
  const raw = localStorage.getItem(LOCAL_AUTH_USERS_KEY);
  if (!raw) return [];
  try {
    return JSON.parse(raw) as LocalUser[];
  } catch {
    return [];
  }
};

const setUsers = (users: LocalUser[]) => {
  localStorage.setItem(LOCAL_AUTH_USERS_KEY, JSON.stringify(users));
};

const getSession = (): LocalSession | null => {
  const raw = localStorage.getItem(LOCAL_AUTH_SESSION_KEY);
  if (!raw) return null;
  try {
    return JSON.parse(raw) as LocalSession;
  } catch {
    return null;
  }
};

const setSession = (session: LocalSession | null) => {
  if (!session) {
    localStorage.removeItem(LOCAL_AUTH_SESSION_KEY);
    return;
  }
  localStorage.setItem(LOCAL_AUTH_SESSION_KEY, JSON.stringify(session));
};

const getMfaState = (): LocalMfaState => {
  const raw = localStorage.getItem(LOCAL_MFA_KEY);
  if (!raw) return {};
  try {
    return JSON.parse(raw) as LocalMfaState;
  } catch {
    return {};
  }
};

const setMfaState = (state: LocalMfaState) => {
  localStorage.setItem(LOCAL_MFA_KEY, JSON.stringify(state));
};

const createId = () => {
  if (typeof crypto !== 'undefined' && 'randomUUID' in crypto) {
    return crypto.randomUUID();
  }
  return `${Date.now()}-${Math.random().toString(16).slice(2)}`;
};

const createToken = () => createId();

const authListeners = new Set<(event: string, session: LocalSession | null) => void>();

const emitAuth = (event: string, session: LocalSession | null) => {
  authListeners.forEach((listener) => listener(event, session));
};

const getCurrentUserId = () => {
  return getSession()?.user?.id || null;
};

const isMfaVerified = (userId: string | null) => {
  if (!userId) return false;
  const state = getMfaState();
  const entry = state[userId];
  if (!entry?.verifiedUntil) return false;
  return entry.verifiedUntil > Date.now();
};

const ensureTable = (db: LocalDb, table: string) => {
  if (!db[table]) db[table] = [];
  return db[table] as Record<string, unknown>[];
};

const allowedTables = new Set(['saved_trips', 'profiles', 'guide_posts', 'blog_posts', 'destinations']);

type RestCountry = {
  name?: { common?: string };
  cca2?: string;
  cca3?: string;
  region?: string;
  subregion?: string;
  capital?: string[];
  latlng?: number[];
  capitalInfo?: { latlng?: number[] };
  flags?: { png?: string; svg?: string };
  currencies?: Record<string, { name?: string; symbol?: string }>;
  landlocked?: boolean;
};

const toSlug = (value: string) => {
  return value
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');
};

const toKey = (value: string) => toSlug(value || '');

const islandNameSet = new Set([
  'bahamas',
  'barbados',
  'cabo-verde',
  'cape-verde',
  'comoros',
  'cuba',
  'dominican-republic',
  'east-timor',
  'fiji',
  'grenada',
  'haiti',
  'iceland',
  'indonesia',
  'ireland',
  'jamaica',
  'japan',
  'kiribati',
  'maldives',
  'marshall-islands',
  'mauritius',
  'micronesia',
  'new-zealand',
  'palau',
  'papua-new-guinea',
  'philippines',
  'saint-kitts-and-nevis',
  'saint-lucia',
  'saint-vincent-and-the-grenadines',
  'samoa',
  'seychelles',
  'singapore',
  'solomon-islands',
  'sri-lanka',
  'taiwan',
  'tonga',
  'trinidad-and-tobago',
  'tuvalu',
  'united-kingdom',
  'vanuatu',
]);

const isIslandCountry = (country: RestCountry, name: string) => {
  const key = toKey(name);
  if (key.includes('island') || key.includes('islands')) return true;
  if (country.region && country.region.toLowerCase() === 'oceania') return true;
  if (islandNameSet.has(key)) return true;
  return false;
};

const seedDestinations = async (db: LocalDb) => {
  const rows = ensureTable(db, 'destinations');
  if (rows.length > 200) return;
  const now = new Date().toISOString();
  const entries: LocalRow[] = [];
  const entryById = new Map<string, LocalRow>();
  const regionByName = new Map<string, LocalRow>();
  const subregionByName = new Map<string, LocalRow>();
  const countryByName = new Map<string, LocalRow>();
  const countryByCode = new Map<string, LocalRow>();

  const addEntry = (entry: LocalRow) => {
    entries.push(entry);
    entryById.set(entry.id as string, entry);
    return entry;
  };

  const ensureRegion = (name: string) => {
    const key = toKey(name);
    const existing = regionByName.get(key);
    if (existing) return existing;
    const entry = addEntry({
      id: `region-${key}`,
      name,
      country: name,
      country_code: null,
      type: 'region',
      types: ['region'],
      image_url: null,
      description: null,
      highlights: [],
      best_season: null,
      average_daily_cost: null,
      currency: null,
      visa_info: null,
      vaccination_info: null,
      health_safety_info: null,
      source: 'restcountries',
      parent_id: null,
      coords_lat: null,
      coords_lon: null,
      children_count: null,
      created_at: now,
    });
    regionByName.set(key, entry);
    return entry;
  };

  const ensureSubregion = (region: LocalRow, name: string) => {
    const key = `${toKey(region.name as string)}-${toKey(name)}`;
    const existing = subregionByName.get(key);
    if (existing) return existing;
    const entry = addEntry({
      id: `region-${key}`,
      name,
      country: region.name,
      country_code: null,
      type: 'region',
      types: ['region'],
      image_url: null,
      description: null,
      highlights: [],
      best_season: null,
      average_daily_cost: null,
      currency: null,
      visa_info: null,
      vaccination_info: null,
      health_safety_info: null,
      source: 'restcountries',
      parent_id: region.id,
      coords_lat: null,
      coords_lon: null,
      children_count: null,
      created_at: now,
    });
    subregionByName.set(key, entry);
    return entry;
  };

  const ensureUniqueId = (base: string) => {
    let id = base;
    let idx = 1;
    while (entryById.has(id)) {
      id = `${base}-${idx}`;
      idx += 1;
    }
    return id;
  };

  try {
    const resp = await fetch('https://restcountries.com/v3.1/all?fields=name,cca2,cca3,region,subregion,capital,latlng,capitalInfo,currencies,flags,landlocked');
    if (!resp.ok) throw new Error('restcountries');
    const list = (await resp.json()) as RestCountry[];
    list.forEach((country) => {
      const name = country.name?.common;
      const cca3 = country.cca3;
      if (!name || !cca3) return;
      const regionName = country.region || 'Other';
      const region = ensureRegion(regionName);
      const subregion = country.subregion ? ensureSubregion(region, country.subregion) : null;
      const types = ['country'];
      if (isIslandCountry(country, name)) types.push('island');
      const currencyCode = country.currencies ? Object.keys(country.currencies)[0] : null;
      const countryEntry = addEntry({
        id: `country-${cca3.toLowerCase()}`,
        name,
        country: name,
        country_code: country.cca2 || null,
        type: 'country',
        types,
        image_url: null,
        description: null,
        highlights: [],
        best_season: null,
        average_daily_cost: null,
        currency: currencyCode,
        visa_info: null,
        vaccination_info: null,
        health_safety_info: null,
        source: 'restcountries',
        parent_id: (subregion?.id as string) || (region.id as string),
        coords_lat: country.latlng?.[0] ?? null,
        coords_lon: country.latlng?.[1] ?? null,
        children_count: null,
        created_at: now,
      });
      countryByName.set(toKey(name), countryEntry);
      if (country.cca2) countryByCode.set(country.cca2.toUpperCase(), countryEntry);
      (country.capital || []).forEach((capital) => {
        if (!capital) return;
        const capitalId = ensureUniqueId(`city-${cca3.toLowerCase()}-${toSlug(capital)}`);
        addEntry({
          id: capitalId,
          name: capital,
          country: name,
          country_code: country.cca2 || null,
          type: 'city',
          types: ['city'],
          image_url: null,
          description: null,
          highlights: [],
          best_season: null,
          average_daily_cost: null,
          currency: currencyCode,
          visa_info: null,
          vaccination_info: null,
          health_safety_info: null,
          source: 'restcountries',
          parent_id: countryEntry.id,
          coords_lat: country.capitalInfo?.latlng?.[0] ?? null,
          coords_lon: country.capitalInfo?.latlng?.[1] ?? null,
          children_count: null,
          created_at: now,
        });
      });
    });
  } catch {
    inspirationDestinations.forEach((d) => {
      addEntry({
        id: d.id,
        name: d.name,
        country: d.country,
        country_code: d.countryCode || null,
        type: d.type,
        types: [d.type],
        image_url: d.imageUrl,
        description: d.description,
        highlights: d.highlights,
        best_season: d.bestSeason || null,
        average_daily_cost: d.averageDailyCost ?? null,
        currency: d.currency || null,
        visa_info: d.visaInfo || null,
        vaccination_info: d.vaccinationInfo || null,
        health_safety_info: d.healthSafetyInfo || null,
        source: d.source || null,
        parent_id: d.parentId || null,
        coords_lat: d.coords?.lat ?? null,
        coords_lon: d.coords?.lon ?? null,
        children_count: d.childrenCount ?? null,
        created_at: now,
      });
    });
  }

  inspirationDestinations.forEach((d) => {
    const nameKey = toKey(d.name);
    const isCountryLevel = toKey(d.name) === toKey(d.country);
    const byName = countryByName.get(nameKey);
    const byCode = isCountryLevel && d.countryCode ? countryByCode.get(d.countryCode.toUpperCase()) : null;
    const target = byName || byCode;
    if (target) {
      const existingTypes = Array.isArray(target.types) ? target.types.slice() : [];
      if (!existingTypes.includes(d.type)) existingTypes.push(d.type);
      target.types = existingTypes;
      target.image_url = d.imageUrl || target.image_url;
      target.description = d.description || target.description;
      target.highlights = d.highlights || target.highlights;
      target.best_season = d.bestSeason || target.best_season;
      target.average_daily_cost = d.averageDailyCost ?? target.average_daily_cost;
      target.currency = d.currency || target.currency;
      target.visa_info = d.visaInfo || target.visa_info;
      target.vaccination_info = d.vaccinationInfo || target.vaccination_info;
      target.health_safety_info = d.healthSafetyInfo || target.health_safety_info;
      target.source = d.source || target.source;
      return;
    }
    const parentFromCode = d.countryCode ? countryByCode.get(d.countryCode.toUpperCase()) : null;
    const id = ensureUniqueId(`dest-${toSlug(d.name)}`);
    addEntry({
      id,
      name: d.name,
      country: d.country,
      country_code: d.countryCode || null,
      type: d.type,
      types: [d.type],
      image_url: d.imageUrl,
      description: d.description,
      highlights: d.highlights,
      best_season: d.bestSeason || null,
      average_daily_cost: d.averageDailyCost ?? null,
      currency: d.currency || null,
      visa_info: d.visaInfo || null,
      vaccination_info: d.vaccinationInfo || null,
      health_safety_info: d.healthSafetyInfo || null,
      source: d.source || null,
      parent_id: (parentFromCode?.id as string) || d.parentId || null,
      coords_lat: d.coords?.lat ?? null,
      coords_lon: d.coords?.lon ?? null,
      children_count: d.childrenCount ?? null,
      created_at: now,
    });
  });

  const childCounts = new Map<string, number>();
  entries.forEach((entry) => {
    if (!entry.parent_id) return;
    const count = childCounts.get(entry.parent_id as string) || 0;
    childCounts.set(entry.parent_id as string, count + 1);
  });
  entries.forEach((entry) => {
    const count = childCounts.get(entry.id as string);
    if (typeof count === 'number') entry.children_count = count;
  });

  rows.splice(0, rows.length, ...entries);
  setLocalDb(db);
};

const localSupabase = {
  auth: {
    onAuthStateChange: (callback: (event: string, session: LocalSession | null) => void) => {
      authListeners.add(callback);
      setTimeout(() => {
        callback('INITIAL_SESSION', getSession());
      }, 0);
      return {
        data: {
          subscription: {
            unsubscribe: () => authListeners.delete(callback),
          },
        },
      };
    },
    getSession: async () => ({ data: { session: getSession() }, error: null }),
    signUp: async ({ email, password, options }: { email: string; password: string; options?: { data?: Record<string, unknown> } }) => {
      const users = getUsers();
      if (users.some((u) => u.email.toLowerCase() === email.toLowerCase())) {
        return { data: null, error: new Error('User already registered') };
      }
      const user = {
        id: createId(),
        email,
        user_metadata: options?.data || {},
      };
      const stored: LocalUser = {
        id: user.id,
        email,
        password,
        user_metadata: user.user_metadata,
      };
      users.push(stored);
      setUsers(users);
      if (stored.user_metadata?.display_name) {
        const db = getLocalDb();
        const profiles = ensureTable(db, 'profiles');
        profiles.push({ user_id: stored.id, display_name: stored.user_metadata.display_name });
        setLocalDb(db);
      }
      const session: LocalSession = {
        user,
        access_token: createToken(),
        refresh_token: createToken(),
      };
      setSession(session);
      emitAuth('SIGNED_IN', session);
      return { data: { user, session }, error: null };
    },
    signInWithPassword: async ({ email, password }: { email: string; password: string }) => {
      const users = getUsers();
      const found = users.find((u) => u.email.toLowerCase() === email.toLowerCase());
      if (!found || found.password !== password) {
        return { data: null, error: new Error('Invalid login credentials') };
      }
      const user = {
        id: found.id,
        email: found.email,
        user_metadata: found.user_metadata || {},
      };
      const session: LocalSession = {
        user,
        access_token: createToken(),
        refresh_token: createToken(),
      };
      setSession(session);
      emitAuth('SIGNED_IN', session);
      return { data: { user, session }, error: null };
    },
    signOut: async () => {
      setSession(null);
      emitAuth('SIGNED_OUT', null);
      return { error: null };
    },
    setSession: async (_tokens: { access_token: string; refresh_token: string }) => {
      return { data: { session: getSession() }, error: null };
    },
    exchangeCodeForSession: async (_code: string) => {
      return { data: { session: getSession() }, error: null };
    },
    updateUser: async ({ password, data }: { password?: string; data?: Record<string, unknown> }) => {
      const session = getSession();
      if (!session?.user?.id) {
        return { data: null, error: new Error('No active session') };
      }
      const users = getUsers();
      const idx = users.findIndex((u) => u.id === session.user.id);
      if (idx === -1) {
        return { data: null, error: new Error('User not found') };
      }
      const updated: LocalUser = {
        ...users[idx],
        password: password || users[idx].password,
        user_metadata: { ...(users[idx].user_metadata || {}), ...(data || {}) },
      };
      users[idx] = updated;
      setUsers(users);
      const nextSession: LocalSession = {
        ...session,
        user: {
          id: updated.id,
          email: updated.email,
          user_metadata: updated.user_metadata || {},
        },
      };
      setSession(nextSession);
      emitAuth('USER_UPDATED', nextSession);
      return { data: { user: nextSession.user }, error: null };
    },
    resetPasswordForEmail: async (_email: string) => ({ data: {}, error: null }),
    resend: async (_payload: { type: string; email: string }) => ({ data: {}, error: null }),
    mfa: {
      listFactors: async () => {
        const userId = getCurrentUserId();
        const verified = isMfaVerified(userId);
        return { data: { totp: [{ id: 'local', status: verified ? 'verified' : 'unverified' }] }, error: null };
      },
      challenge: async (_payload: { factorId: string }) => {
        const userId = getCurrentUserId();
        if (!userId) {
          return { data: null, error: new Error('No active session') };
        }
        const code = Math.floor(100000 + Math.random() * 900000).toString();
        const challengeId = createId();
        const expiresAt = Date.now() + 5 * 60 * 1000;
        const state = getMfaState();
        state[userId] = { ...state[userId], challengeId, code, expiresAt };
        setMfaState(state);
        return { data: { id: challengeId, expires_at: new Date(expiresAt).toISOString(), code }, error: null };
      },
      verify: async (payload: { factorId: string; challengeId: string; code: string }) => {
        const userId = getCurrentUserId();
        if (!userId) {
          return { data: null, error: new Error('No active session') };
        }
        const state = getMfaState();
        const entry = state[userId];
        if (!entry?.challengeId || entry.challengeId !== payload.challengeId) {
          return { data: null, error: new Error('Challenge invalid') };
        }
        if (!entry.expiresAt || entry.expiresAt < Date.now()) {
          return { data: null, error: new Error('Challenge expired') };
        }
        if (entry.code !== payload.code) {
          return { data: null, error: new Error('Code invalid') };
        }
        state[userId] = { ...entry, verifiedUntil: Date.now() + 8 * 60 * 60 * 1000 };
        setMfaState(state);
        return { data: { currentLevel: 'aal2' }, error: null };
      },
      getAuthenticatorAssuranceLevel: async () => {
        const userId = getCurrentUserId();
        const verified = isMfaVerified(userId);
        return { data: { currentLevel: verified ? 'aal2' : 'aal1' }, error: null };
      },
    },
  },
  from: (table: string): LocalQueryBuilder => {
    let action: 'select' | 'insert' | 'update' | 'delete' | 'upsert' = 'select';
    let payload: LocalRow | LocalRow[] | null = null;
    let selectColumns: string | null = null;
    const filters: { key: string; value: unknown; type: 'eq' | 'ilike' }[] = [];
    let orderBy: { key: string; ascending: boolean } | null = null;
    let single = false;

    const applyFilters = (rows: Record<string, unknown>[]) => {
      return rows.filter((row) => {
        return filters.every((f) => {
          const value = row[f.key];
          if (f.type === 'ilike') {
            const search = String(f.value || '').toLowerCase().replace(/%/g, '');
            return String(value || '').toLowerCase().includes(search);
          }
          return value === f.value;
        });
      });
    };

    const execute = async (): Promise<LocalQueryResult> => {
      if (!allowedTables.has(table)) {
        return { data: null, error: new Error('Local table not available') };
      }
      const db = getLocalDb();
      if (table === 'destinations') await seedDestinations(db);
      const rows = ensureTable(db, table);
      let result: LocalRow[] = rows.slice();
      if (filters.length) result = applyFilters(result);

      if (action === 'select') {
        if (orderBy) {
          result.sort((a, b) => {
            const av = a[orderBy.key];
            const bv = b[orderBy.key];
            if (av === bv) return 0;
            if (av === undefined || av === null) return orderBy.ascending ? 1 : -1;
            if (bv === undefined || bv === null) return orderBy.ascending ? -1 : 1;
            return (av > bv ? 1 : -1) * (orderBy.ascending ? 1 : -1);
          });
        }
        if (selectColumns && selectColumns !== '*') {
          const cols = selectColumns.split(',').map((c) => c.trim());
          result = result.map((row) => {
            const picked: Record<string, unknown> = {};
            cols.forEach((c) => {
              picked[c] = row[c];
            });
            return picked;
          });
        }
        if (single) {
          return { data: result[0] ?? null, error: null };
        }
        return { data: result, error: null };
      }

      if (action === 'insert') {
        const toInsert = Array.isArray(payload) ? payload : [payload];
        const inserted = toInsert.map((row) => ({
          ...row,
          id: (row as LocalRow)?.id || createId(),
          created_at: (row as LocalRow)?.created_at || new Date().toISOString(),
        }));
        rows.unshift(...inserted);
        setLocalDb(db);
        return { data: inserted, error: null };
      }

      if (action === 'upsert') {
        const toUpsert = Array.isArray(payload) ? payload : [payload];
        const updated: LocalRow[] = [];
        toUpsert.forEach((row) => {
          const id = (row as LocalRow)?.id || createId();
          const idx = rows.findIndex((r) => r.id === id);
          const next: LocalRow = { ...(rows[idx] || {}), ...(row as LocalRow), id };
          if (idx === -1) {
            rows.unshift({ ...next, created_at: next.created_at || new Date().toISOString() });
          } else {
            rows[idx] = next;
          }
          updated.push(next);
        });
        setLocalDb(db);
        return { data: updated, error: null };
      }

      if (action === 'update') {
        const updated: Record<string, unknown>[] = [];
        rows.forEach((row, idx) => {
          if (applyFilters([row]).length) {
            const next = { ...row, ...(payload as LocalRow) };
            rows[idx] = next;
            updated.push(next);
          }
        });
        setLocalDb(db);
        return { data: updated, error: null };
      }

      if (action === 'delete') {
        const remaining = rows.filter((row) => !applyFilters([row]).length);
        const deleted = rows.filter((row) => applyFilters([row]).length);
        db[table] = remaining;
        setLocalDb(db);
        return { data: deleted, error: null };
      }

      return { data: null, error: null };
    };

    const builder: LocalQueryBuilder = {
      select: (columns?: string) => {
        action = 'select';
        selectColumns = columns || '*';
        return builder;
      },
      insert: (data: LocalRow | LocalRow[]) => {
        action = 'insert';
        payload = data;
        return builder;
      },
      upsert: (data: LocalRow | LocalRow[]) => {
        action = 'upsert';
        payload = data;
        return builder;
      },
      update: (data: LocalRow) => {
        action = 'update';
        payload = data;
        return builder;
      },
      delete: () => {
        action = 'delete';
        return builder;
      },
      eq: (key: string, value: unknown) => {
        filters.push({ key, value, type: 'eq' });
        return builder;
      },
      ilike: (key: string, value: unknown) => {
        filters.push({ key, value, type: 'ilike' });
        return builder;
      },
      order: (key: string, opts?: { ascending?: boolean }) => {
        orderBy = { key, ascending: opts?.ascending !== false };
        return builder;
      },
      single: () => {
        single = true;
        return builder;
      },
      then: (resolve, reject) => execute().then(resolve, reject),
    };

    return builder;
  },
};

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = (isLocalSupabase
  ? (localSupabase as unknown as ReturnType<typeof createClient<Database>>)
  : createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
      auth: {
        storage: localStorage,
        persistSession: true,
        autoRefreshToken: true,
      },
    })) as ReturnType<typeof createClient<Database>>;
